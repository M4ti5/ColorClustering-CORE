using System; using System.Diagnostics;
using System.Drawing; using System.Linq;  namespace ColorClustering {     public class KMeans {          private Image image;          private KNode[] pixelMap;         private KNode[] alteredPixelMap;          private byte[] redMap;         private byte[] greenMap;         private byte[] blueMap;          private KNode[] clusters;         private bool isClustered = false;          public KMeans(Image _image, byte k, int t, String method) {
            Stopwatch time = new Stopwatch();
            Stopwatch mainTime = new Stopwatch();

            Console.WriteLine("Kmeans Start ...");
            time.Start();
            mainTime.Start();              image = _image;             redMap = image.GetRedMap();             greenMap = image.GetGreenMap();             blueMap = image.GetBlueMap();              pixelMap = new KNode[image.height * image.width];             alteredPixelMap = new KNode[image.width * image.height];              for (int i = 0; i < image.width * image.height; i++) {                 pixelMap[i] = new KNode(redMap[i], greenMap[i], blueMap[i]);             }  
            Console.WriteLine("Clustering with "+method+"...");
            Clustering(k , t , method);
            time.Stop();
            Console.WriteLine("Clustering it's Okey!");
            Console.WriteLine("Clustering time : " + time.Elapsed.ToString());             Console.WriteLine("Clustering it's Okey!");              time.Restart();
            Console.WriteLine("Alteration...");
            Alteration();
            time.Stop();
            Console.WriteLine("Alteration it's Okey!");
            Console.WriteLine("Alteration time : " + time.Elapsed.ToString());              mainTime.Stop();             Console.WriteLine("Kemeans time : " + mainTime.Elapsed.ToString());         }          public void Clustering(byte k, int t, String method) {             /* 			 * k : number of cluster 			 * t : number of iteration 			 */              clusters = new KNode[k];             Random random = new();              //Creation of Clusters with Random Position              for (byte ki = 0; ki < k; ki++) {                 byte[] randomNumbers = new byte[3];                 random.NextBytes(randomNumbers);                 clusters[ki] = new KNode(randomNumbers[0], randomNumbers[1], randomNumbers[2]);             }              //Clear bind with old Clusters             if (isClustered) {                 for (int pi = 0; pi < image.width * image.height; pi++) { // for all pixels                     pixelMap[pi].bindedCluster = null;                 }             }                //Iteration Loop             for (int i = 0; i < t; i++) {                                 int[,] kSumPosition = new int[k, 3];                 int[] kElement = new int[k];                  //Binding of pixel with a cluster                 for (int pi = 0; pi < image.width * image.height; pi++) { // for all pixels                      //Decision of binding                     double[] kDistance = new double[k];                      for (byte ki = 0; ki < k; ki++) {// for all clusters                          if(method == "Manhattan" || method == "MANHATTAN") {                             kDistance[ki] = ManhattanDistance(clusters[ki], pixelMap[pi]);                                                  } else {                             kDistance[ki] = EuclidianDistance(clusters[ki], pixelMap[pi]);                         }                     }                      pixelMap[pi].bindedCluster = (byte)kDistance.ToList().IndexOf(kDistance.Min());                       //Pre-calcul of future cluster's position                      kSumPosition[(int)pixelMap[pi].bindedCluster, 0] += pixelMap[pi].red;//Red sum position                     kSumPosition[(int)pixelMap[pi].bindedCluster, 1] += pixelMap[pi].green;//Green sum position                     kSumPosition[(int)pixelMap[pi].bindedCluster, 2] += pixelMap[pi].blue;//Blue sum position                      kElement[(int)pixelMap[pi].bindedCluster] += 1;                 }                  //Shifting clusters' position                  for (byte ki = 0; ki < k; ki++) {// for all clusters                     if(kElement[ki] != 0) {
                        byte r = (byte)( ( kSumPosition[ki , 0] / kElement[ki] ));
                        byte g = (byte)( ( kSumPosition[ki , 1] / kElement[ki] ));
                        byte b = (byte)( ( kSumPosition[ki , 2] / kElement[ki] ));
                        clusters[ki].setPixel(r , g , b);
                    }                                      }                 Console.WriteLine("End of iteration " + (i+1) + "/" + t);             }

            //Print all colors of clusters
            Console.WriteLine("--------------------- Cluster's Values --------------------- ");             Console.WriteLine("We have " + k + " Cluster(s)");             for (byte ki = 0; ki < k; ki++) {// for all clusters                 KNode temp = clusters[ki];                 Console.WriteLine("Cluster " + ki + " Color "+" : R" + temp.red +  " G" + temp.green + " B" + temp.blue);             }
            Console.WriteLine("------------------------------------------------------------ ");              isClustered = true;         }          private double EuclidianDistance(KNode a, KNode b) {              return Math.Pow((a.red - b.red) * ( a.red - b.red )  + (a.green - b.green)* ( a.green - b.green ) + (a.blue - b.blue)* ( a.blue - b.blue ) , 0.5);          }          private double ManhattanDistance(Pixel a, Pixel b) {              return ( (a.red - b.red) > 0 ? ( a.red - b.red ) : -( a.red - b.red ) )                      + ( ( a.green - b.green ) > 0 ? ( a.green - b.green ) : -( a.green - b.green ) )                     + ( ( a.blue - b.blue ) > 0 ? ( a.blue - b.blue ) : -( a.blue - b.blue ) );          }          public void Alteration() {             if (isClustered) {                                  for (int pi = 0; pi < image.width * image.height; pi++) { // for all pixels                     KNode ki = clusters[(byte)pixelMap[pi].bindedCluster];                      alteredPixelMap[pi] = new KNode(ki.red, ki.green, ki.blue);                 }                               } else {                 Console.WriteLine("You must clusterized your picture before a alteration");             }         }          public Bitmap Draw() {             if (isClustered) {                 Bitmap newImage = image.bitmap;                  for (int y = 0; y < image.height; y++) {                     for (int x = 0; x < image.width; x++) {                         newImage.SetPixel(x, y, alteredPixelMap[image.width * y + x].ToColor());                     }                 }                  Console.WriteLine("It's Drawn!");                 return newImage;              } else {                 Console.WriteLine("You must clusterized your picture before drawing");                 return null;             }         }          public void Print () {             //Creation of new picture              String newPath = image.path[..^4] + "New" + image.path[^4..]; //Change the name of new file             Draw().Save(newPath); // Print the picture          }      } }  